function next_state = static_feedback(deltaTRk, state, measurements, ...
                                      gain_mode)
    prediction = [];
    prediction.position = state.position + ...
        deltaTRk * state.velocity + ...
        0.5 * deltaTRk^2 * state.acceleration;
    prediction.velocity = state.velocity + ...
        deltaTRk * state.acceleration;
    prediction.acceleration = state.acceleration;
    prediction.clock_offset = state.clock_offset + ...
        deltaTRk * state.clock_rate_offset;
    prediction.clock_rate_offset = state.clock_rate_offset;

    innovation = [];
    innovation.position = measurements.position - prediction.position;
    innovation.velocity = measurements.velocity - prediction.velocity;
    innovation.clock_offset = measurements.clock_offset - ...
        prediction.clock_offset;
    innovation.clock_rate_offset = measurements.clock_rate_offset - ...
        prediction.clock_rate_offset;

    next_state = [];
    
    if strcmp(gain_mode, 'slow')
        next_state.position = prediction.position + ...
            8.44567e-3 * innovation.position + ...
            0.508214 * deltaTRk * innovation.velocity;
        next_state.velocity = prediction.velocity + ...
            3.67184e-5/deltaTRk * innovation.position + ...
            0.975104 * innovation.velocity;
        next_state.acceleration = prediction.acceleration + ...
            -3.29082e-5/deltaTRk^2 * innovation.position + ...
            0.927802/deltaTRk * innovation.velocity;
        next_state.clock_offset = prediction.clock_offset + ...
            8.462e-3 * innovation.clock_offset + ...
            0.0271035 * deltaTRk * innovation.clock_rate_offset;
        next_state.clock_rate_offset = prediction.clock_rate_offset + ...
            1.95823e-6/deltaTRk * innovation.clock_offset + ...
            0.972659 * innovation.clock_rate_offset;
    elseif strcmp(gain_mode, 'fast')
        next_state.position = prediction.position + ...
            8.44612e-3 * innovation.position + ...
            0.495778 * deltaTRk * innovation.velocity;
        next_state.velocity = prediction.velocity + ...
            3.582e-5/deltaTRk * innovation.position + ...
            0.999979 * innovation.velocity;
        next_state.acceleration = prediction.acceleration + ...
            -3.55164e-5/deltaTRk^2 * innovation.position + ...
            1.000009/deltaTRk * innovation.velocity;
        next_state.clock_offset = prediction.clock_offset + ...
            8.46395e-3 * innovation.clock_offset + ...
            2.86552e-6 * deltaTRk * innovation.clock_rate_offset;
        next_state.clock_rate_offset = prediction.clock_rate_offset + ...
            2.07034e-10/deltaTRk * innovation.clock_offset + ...
            0.999997 * innovation.clock_rate_offset;
    end
    
    next_state.innovation = [ 
        innovation.position; 
        innovation.velocity; 
        innovation.clock_offset; 
        innovation.clock_rate_offset
    ];
    next_state.time = measurements.time;
end